import Foundation
import GRDB
@testable import OfflineBrowser

/// Creates an in-memory GRDB database for testing with the same schema as production
final class TestDatabaseManager {

    /// Creates a new in-memory database queue with migrations applied
    /// Note: Uses DatabaseQueue instead of DatabasePool because WAL mode
    /// doesn't work with in-memory databases
    static func makeInMemoryDatabaseQueue() throws -> DatabaseQueue {
        let dbQueue = try DatabaseQueue(path: ":memory:")
        try migrator.migrate(dbQueue)
        return dbQueue
    }

    /// For compatibility - wraps DatabaseQueue as DatabasePool isn't supported for :memory:
    /// Uses a temporary file-based database instead
    static func makeInMemoryDatabasePool() throws -> DatabasePool {
        // Create a unique temp file for each test to avoid conflicts
        let tempDir = FileManager.default.temporaryDirectory
        let dbPath = tempDir.appendingPathComponent("test_\(UUID().uuidString).sqlite").path
        let dbPool = try DatabasePool(path: dbPath)
        try migrator.migrate(dbPool)
        return dbPool
    }

    /// Same migrations as production DatabaseManager
    private static var migrator: DatabaseMigrator {
        var migrator = DatabaseMigrator()

        // Migration 1: Initial schema (same as production)
        migrator.registerMigration("v1_initial") { db in
            // Folders table
            try db.create(table: "folders") { t in
                t.column("id", .text).primaryKey()
                t.column("name", .text).notNull()
                t.column("isAutoGenerated", .boolean).notNull().defaults(to: false)
                t.column("createdAt", .datetime).notNull()
            }

            // Videos table
            try db.create(table: "videos") { t in
                t.column("id", .text).primaryKey()
                t.column("title", .text).notNull()
                t.column("sourceURL", .text).notNull()
                t.column("sourceDomain", .text).notNull()
                t.column("filePath", .text).notNull()
                t.column("thumbnailPath", .text)
                t.column("subtitlePath", .text)
                t.column("duration", .integer).notNull().defaults(to: 0)
                t.column("fileSize", .integer).notNull().defaults(to: 0)
                t.column("quality", .text).notNull()
                t.column("folderID", .text).references("folders", onDelete: .setNull)
                t.column("createdAt", .datetime).notNull()
                t.column("lastPlayedAt", .datetime)
                t.column("playbackPosition", .integer).notNull().defaults(to: 0)
            }

            // Downloads table
            try db.create(table: "downloads") { t in
                t.column("id", .text).primaryKey()
                t.column("videoURL", .text).notNull()
                t.column("manifestURL", .text)
                t.column("pageTitle", .text)
                t.column("pageURL", .text)
                t.column("sourceDomain", .text)
                t.column("status", .text).notNull()
                t.column("progress", .double).notNull().defaults(to: 0)
                t.column("segmentsDownloaded", .integer).notNull().defaults(to: 0)
                t.column("segmentsTotal", .integer).notNull().defaults(to: 0)
                t.column("retryCount", .integer).notNull().defaults(to: 0)
                t.column("errorMessage", .text)
                t.column("quality", .text)
                t.column("encryptionKeyURL", .text)
                t.column("createdAt", .datetime).notNull()
                t.column("updatedAt", .datetime).notNull()
            }

            // Preferences table
            try db.create(table: "preferences") { t in
                t.column("key", .text).primaryKey()
                t.column("value", .text).notNull()
            }

            // Indexes
            try db.create(index: "videos_folderID", on: "videos", columns: ["folderID"])
            try db.create(index: "videos_sourceDomain", on: "videos", columns: ["sourceDomain"])
            try db.create(index: "downloads_status", on: "downloads", columns: ["status"])
        }

        return migrator
    }
}
